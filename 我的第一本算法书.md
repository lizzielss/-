# 我的第一本算法书

# 第一章 数据结构

### 1.1 链表

每个数据有一个指针，指向下一个数据的内存地址。“顺序访问”

删除增加数据，操作只需要改变指针。

循环链表、双向链表。

### 1.2 数组

每个数据的内存地址通过访问数组下标算出。“随机访问”

删除和增加数据比链表麻烦。

### 1.3 栈

只能访问最新添加的数据。“后进先出”

删除和添加操作只能在一端进行。

DFS选用最新数据作为候补顶点，可用栈管理候补顶点。

### 1.4 队列

类比生活中的“排队”。“先进先出”

删除和添加操作在两端进行。

BFS选用最早的数据作为下一个顶点，可用队列管理候补顶点。

### 1.5 哈希表

数据由“键”和“值”组成。

哈希函数计算“键”的哈希值，mod后得到数组下标中。若某下标有多个目标（哈希冲突），可使用链表存储。

给数组设定合适空间（太大，内存浪费；太小，容易哈希冲突）

发生哈希冲突：“链地址法”、“开放地址法”、“线性探测法”、多次哈希。

### 1.6 堆

图的树形结构。实现“优先队列”（取出数据从最小值按顺序取出）。

规则：每个结点最多有两个子节点。子节点必定大于父子节点。

取出数据后需要将最后的数据移到最顶端，和子节点比较大小。数据总量为$n$，重构树的时间与树高$log_2(n)$成正比，时间复杂度$O(log_2(n))$。添加数据同理。

### 1.7 二叉查找树

每个节点最多有两个子节点。

规则：每个结点的值均大于其左子树上任意一个结点的值。每个结点的值均小于其右子树上任意一个结点的值。

查找最小值：从顶端开始，往其左下末端寻找。
查找最大值：从顶端开始，往其右下末端寻找。

添加：从顶点开始，与当前结点比较，小于它左移，大于它右移。
删除：①没有子节点，直接删除；②有一个子节点，子节点移到被删除位置；③有两个子节点，左子树中找最大结点（或右子树最小结点），移到被删除结点位置。

树比较均衡，时间复杂度$O(log_2(n))$；树单向延伸，时间复杂度$O(n)$

“平衡二叉查找树”：修正形状不均衡的树。
“B树”：子节点数可自由设定，形状均衡。

## 第二章 排序

### 2.1冒泡排序

从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置。

时间复杂度$O(n^2)$

### 2.2 选择排序法

从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换。“线性查找”

时间复杂度$O(n^2)$

### 2.3 插入排序

从右侧的未排序区域内取出一个数，然后将它插入到已排序区域的合适位置上。

时间复杂度$O(n^2)$

### 2.4 堆排序

降序构造堆，依次取出最大值，重新构造堆。

每轮重构$O(log_2(n))$，一共$n$轮，时间复杂度$O(nlog_2(n))$

### 2.5 归并排序

把序列分成长度相同的两个子序列，无法继续往下分时（每个子序列只有一个值），对子序列进行归并。

完成一行归并所需要的时间取决于这一行的数据量。，长度为n的序列可以分为$log_2(n)$行，时间复杂度$O(nlog_2(n))$

### 2.6 快速排序

在序列中随机选择一个基准值，然后将除了基准值意外的数分为“比基准值小的数”和“比基准值大的数”，并在其中也运用相同的办法排列。

“分治法”：将原来的问题分成两个子问题，然后再分别解决这两个子问题。

平均运行时间：$O(nlog_2(n))$                                                              

## 3 数组的查找

### 3.1 线性查找

在数组中从头开始依次往下查找。

时间复杂度$O(n)$

### 3.2 二分查找

只能查找排好序的数据。比较数组中间的数据与目标数据大小，得知目标数据在数组左边还是右边。重复执行该操作就可以找到目标数据。

时间复杂度$O(log_2(n))$

## 4 图的搜索

### 4.1 广度优先搜索

优先从离起点近的顶点开始搜索。候补顶点“先入先出”（队列数据结构），由近及远进行广泛的搜索。

### 4.2 深度优先搜索

沿着一条路径不断往下搜索直到不能再继续为止，然后再这番，开始搜索下一条候补路径。“后入先出”（栈数据结构）

### 4.3 Bellman- Ford算法

图定点数为n，边数为m，经过n轮更新操作后停止，每轮更新操作中对各个边进行1次确认。时间复杂度$O(nm)$

输入的权重为负值时，也可以正常运行。

### 4.4 Dijkstra算法

根据最小权重选择候选顶点。图定点数为n，边数为m，事先不进行任何处理，时间复杂度$O(n^2)$，对数据结构进行优化，时间复杂度$O(m+nlog_2(n))$

输入的权重为负值时，算法失效。

### 4.5 A*算法

由Dijkstra发展而来。先预估起点和终点的距离，省去一些无用的计算。

<img src="C:%5CUsers%5CLizzie%5CDesktop%5C2019-autumn%5C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%5C%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6%5C%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6.assets%5Cimage-20191122134620892.png" alt="image-20191122134620892" style="zoom:33%;" />

距离估计值（方块右下）越接近当前顶点到终点的实际值，算法的搜索效率越高。当距离估算值小于实际距离时，是一定可以得到正确答案的。

游戏编程中常用于计算敌人追赶玩家时的行动路线。

## 5 安全算法

问题：窃听（加密）、假冒（消息认证码或者数字签名）、篡改（消息认证码或者数字签名）、事后否认（数字签名）

### 5.1 哈希函数

哈希函数可以把给定的数据转换成**固定长度的无规律数值**。转换后的无规律数值可以作为**数据摘要**。

特征：输出长度不变；输入相同则输出相同；输入即使只有一比特差别输出有很大差异；输入不同可能得到相同输出（哈希冲突）；从哈希值反推输入很难；哈希值的计算过程相对容易。

代表算法：MD5、SHA-1、SHA-2

### 5.2 共享密钥加密

加密和解密都使用相同的密钥。

代表算法：凯撒密码、AES、DES、动态口令等。

密钥分配问题：密钥交换协议、公开密钥加密。

### 5.3 公开密钥加密

加密和解密使用不同密钥。

代表算法：RSA算法、椭圆曲线加密算法。

问题：随着通人数增多，密钥需求增多。n个人需要$n(n-1)/2$

​			“中间人攻击”（数字证书）

​			加密解密速度较慢。（混合加密）

### 5.4 混合加密

结合共享密钥加密和公开密钥加密的技术。

用公钥加密共享密钥。然后用共享密钥通信。

SSL（安全套接层）应用了混合加密。

### 5.5 Diffie-Hellman密钥交换

在通信双方之间安全交换密钥。通过将双方共有的秘密数值隐藏在公开数值相关的运算中，实现密钥的安全交换。通信双方仅交换一些公开信息就可以实现密钥交换。

合成密钥：

三个特点：即使持有其中一个密钥和合成密钥也无法把另外一个密钥取出来。

​					合成来的密钥可以继续和其他密钥进行合成。

​					密钥合成结果与合成顺序无关。

<img src="C:%5CUsers%5CLizzie%5CDesktop%5C2019-autumn%5C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%5C%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6%5C%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6.assets%5Cimage-20191122225043256.png" alt="image-20191122225043256" style="zoom:50%;" />

“离散对数问题”：根据素数P，生成元G和“$G^XmodP$”求出X的问题。

### 5.6 消息认证码

可以实现“认证”和“检测篡改”两个功能。

> 1. 发信方生成一个用于制作消息认证码的密钥，并通过安全的方式发给接收方。、
> 2. 发送方将此密钥与密文哈希得到一个哈希值，即消息认证码MAC，将密文和哈希值发送到接收方。
> 3. 接收方根据生成的密钥和密文得到的哈希值与MAC值比较，相同则说明未发生篡改。

计算MAC的算法：HMAC、OMAC、CMAC。

问题：生成的一方和检测的一方持有相同的密钥（共享密钥加密），不能确定MAC由哪一方生成，会出现“事后否定”等问题。

### 5.7 数字签名

数字签名只有发信人才能生成。（公开密钥加密）

发信人用私钥加密明文的哈希值得到签名，收信方对签名公钥解密，看是否和收到的消息一致。

“签名”：只能由发送方加密的的密文

问题：公开密钥加密无法确定公开密钥的制作人是谁。（“数字证书”）

### 5.8 数字证书

> 1. 发信方将公钥和自己的地址信息发给CA。
> 2. CA根据地址判断发信方的身份，用自己的私钥生成数字签名，与发信方的公钥和地址信息生成数字证书。
> 3. 发信方将数字证书发给收信方。
> 4. 收信方确认发信方的地址后，向CA请求其公钥，解开数字证书的签名，验证数字证书的权威性，获得发信方的公钥。

个人证书与邮箱信息对应，服务器证书与域名信息相对应。

## 6 聚类

### 6.1 K-mens算法

可以根据事先给定的簇的数量进行聚类。

> 1. 随机选择k个点作为簇的中心点。
> 2. 计算各数据分别和k个中心点的哪个距离最近，将数据分到相应的簇中。
> 3. 计算各簇中数据的重心，作为簇的中心点。
> 4. 重复直到中心点不发生变化

注意：随机设置的中心点不一样，也会影响聚类结果。

其他算法：层次聚类法

## 7 其他算法

### 7.1 欧几里得算法（辗转相除法）

用于计算两个数的最大公约数。

> 1. 用较大的数字除以较小的数字，得到余数。
> 2. 用较小的数字除以余数，得到另外一个余数。
> 3. 将第一个余数除以第二个余数，得到第三个余数。
> 4. 重复直到余数为0，最后一次运算中的除数就是最大公约数。

### 7.2 素性测试

判断一个自然数是否为素数。

素数：只能被1和自身整除，且大于1的数。

费马测试：某个数是素数的概率大不大。

> 费马小定理：
>
> $p = 素数$
> $n < p$
> $n^p$ mod $p=n$

卡迈克尔数：绝对伪素数，满足费马小定理的合数。数量非常小。

### 7.3 网页排名

利用网络之间的链接结构计算出网页价值。

链入页面越多，重要性越大。

随机游走解决环状链接问题。

### 7.4 汉诺塔

递归算法。

时间：$T(n)=2T(n-1)+1$，$T(n)=2^n-1$

